{
  "hash": "c3b7856ca4cd2ef08fcd3b956a6be231",
  "result": {
    "markdown": "---\ntitle: \"Challenge 3 - Australian Marriage\"\nauthor: \"Srujan Kagitala\"\ndescription: \"Tidy Data: Pivoting\"\ndate: \"6/26/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_3\n  - australian_marriage\n  - srujan_kagitala\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1.  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2.  identify what needs to be done to tidy the current data\n3.  anticipate the shape of pivoted data\n4.  pivot the data into tidy format using `pivot_longer`\n\n## Read in data\n\nRead in one (or more) of the following datasets, using the correct R package and command.\n\n-   australian_marriage\\*.xls ⭐⭐⭐\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#read data\nmarriage_data <- read.csv(\"_data/australian_marriage_tidy.csv\")\n\n#print head of read data.\nhead(marriage_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        territory resp   count percent\n1 New South Wales  yes 2374362    57.8\n2 New South Wales   no 1736838    42.2\n3        Victoria  yes 2145629    64.9\n4        Victoria   no 1161098    35.1\n5      Queensland  yes 1487060    60.7\n6      Queensland   no  961015    39.3\n```\n:::\n:::\n\n\n### Briefly describe the data and Anticipate the End Result\n\nDescribe the data, and be sure to comment on why you are planning to pivot it to make it \"tidy\"\n\nThe data set I choose is Australian marriage. It looks like it captures the responses of participants to a survey across regions in Australia. The data set has 16 rows and 4 columns. The variables recorded for each observation are territory, resp, count, percent. The data currently records two observations for each region in Australia. So, I want to tidy the data to represent all the responses and their statistics specific to an area into a single observation. For this, we need to convert the values \"resp\" variable can take to independent variables and assign values from count and percent variables. The tidied data set will contain territory, yes/no count, yes/no percent for each observation. \n\n### Challenge: Describe the final dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unique values of resp variable.\nno_unqiue_resp_values = length(unique(marriage_data$resp))\n\n#expected rows\nrows = nrow(marriage_data)/no_unqiue_resp_values\n\n#expected columns\ncolumns = (ncol(marriage_data) - 2)* no_unqiue_resp_values + 1\n```\n:::\n\n\nThe number of unique values the resp variable has are 2. After pivoting wider, the data set will have 8 rows and 5 columns. So, the pivoted data set will have 8x5 dimension.\n\n### Challenge: Pivot the Chosen Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#pivot wider on resp variable with values from count and percent\nmarriage_pivot <- marriage_data %>%\n  pivot_wider(names_from=resp, values_from=c(count, percent))\nmarriage_pivot\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  territory                       count_yes count_no percent_yes percent_no\n  <chr>                               <int>    <int>       <dbl>      <dbl>\n1 New South Wales                   2374362  1736838        57.8       42.2\n2 Victoria                          2145629  1161098        64.9       35.1\n3 Queensland                        1487060   961015        60.7       39.3\n4 South Australia                    592528   356247        62.5       37.5\n5 Western Australia                  801575   455924        63.7       36.3\n6 Tasmania                           191948   109655        63.6       36.4\n7 Northern Territory(b)               48686    31690        60.6       39.4\n8 Australian Capital Territory(c)    175459    61520        74         26  \n```\n:::\n:::\n\n\nThe dimensions of dataset after pivoting longer match with the calculated dimension.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}